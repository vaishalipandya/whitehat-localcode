using System;
using System.Globalization;
using Newtonsoft.Json;
using System.IO;
using System.Net;
using WhiteHatSec.Entity;
using WhiteHatSec.Shared;

namespace WhiteHatSec.Services
{
    /// <summary>
    ///     Call REST API of WhiteHat Sentinel Vulnerability
    /// </summary>
    public class VulnerabilityService
    {
        #region "Get Applications Vuln data "

        private static string DISPLAY_PATCHES = "&display_patches=1";

        /// <summary>
        ///     Gets the vuln data by ApplicationId -Sentinel Cookie/API key.
        /// </summary>
        /// <param name="sentinelServerUrl">The sentinel  server.</param>
        /// <param name="sentinelCookie">The cookies.</param>
        /// <param name="applicationId">The application id.</param>
        /// <param name="apiKey">The API key.</param>
        /// <returns></returns>
        public static ApplicationVulnerabilityInfo.AppsVulnsData GetVulnData(string sentinelServerUrl, CookieContainer sentinelCookie, string applicationId, string risk, string status, string fromDate, string ToDate, string apiKey)
        {
            sentinelServerUrl = Constant.CleanUrl(sentinelServerUrl);
            string appVulnUrl;

            ServicePointManager.ServerCertificateValidationCallback = delegate { return true; };
            ServicePointManager.Expect100Continue = true;
            ServicePointManager.SecurityProtocol = SecurityProtocolType.Ssl3 | SecurityProtocolType.Tls | SecurityProtocolType.Tls11 | SecurityProtocolType.Tls12;
            ServicePointManager.CheckCertificateRevocationList = false;

            appVulnUrl = apiKey != string.Empty ? string.Format(Constant.VulnByApiKeyUrl, sentinelServerUrl, applicationId, risk, status, fromDate, ToDate, apiKey) :
                 string.Format(Constant.VulnByAppUrl, sentinelServerUrl, applicationId, risk, status, fromDate, ToDate);
            appVulnUrl += Constant.getMetricsString();
            HttpWebRequest applicationVulnrequest = WebRequest.CreateHttp(appVulnUrl);
            applicationVulnrequest.CookieContainer = sentinelCookie;
            applicationVulnrequest.AllowAutoRedirect = false;
            applicationVulnrequest.UserAgent = Constant.UserAgent;
            applicationVulnrequest.Headers[HttpRequestHeader.AcceptLanguage] = Constant.AcceptLanguage;
            applicationVulnrequest.Headers[HttpRequestHeader.CacheControl] = Constant.CacheControl;
            applicationVulnrequest.Method = "GET";
            string applicationVulnData;
            HttpWebResponse applicationVulnResponse = (HttpWebResponse)applicationVulnrequest.GetResponse();

            using (StreamReader reader = new StreamReader(applicationVulnResponse.GetResponseStream()))
            {
                applicationVulnData = reader.ReadToEnd();
            }

            applicationVulnResponse.Close();
            return JsonConvert.DeserializeObject<ApplicationVulnerabilityInfo.AppsVulnsData>(applicationVulnData);
        }

        #endregion

        #region "Get Vuln Detail "

        /// <summary>
        ///     Gets the vuln detail for Vuln ID by Cookie/ApiKey.
        /// </summary>
        /// <param name="sentinelServerUrl">The sentinel server URL.</param>
        /// <param name="sentinelCookies">The sentinel cookies.</param>
        /// <param name="apiKey">The api Key.</param>      
        /// <param name="vulnId">The vuln id.</param>
        /// <param name="isGetdetails"></param>
        /// <returns></returns>
        public static VulnerabilityInfo.Vulnerability GetVulnDetail(string sentinelServerUrl, CookieContainer sentinelCookies, string apiKey, string vulnId, bool isGetdetails)
        {
            sentinelServerUrl = Constant.CleanUrl(sentinelServerUrl);
            string vulnDetailUrl;

            ServicePointManager.ServerCertificateValidationCallback = delegate { return true; };
            ServicePointManager.Expect100Continue = true;
            ServicePointManager.SecurityProtocol = SecurityProtocolType.Ssl3 | SecurityProtocolType.Tls | SecurityProtocolType.Tls11 | SecurityProtocolType.Tls12;
            ServicePointManager.CheckCertificateRevocationList = false;

            vulnDetailUrl = apiKey == string.Empty ? string.Format(Constant.VulnDetailCookieUrl, sentinelServerUrl, vulnId, Convert.ToInt32(isGetdetails), Convert.ToInt32(isGetdetails)):
                string.Format(Constant.VulnDetailKeyUrl, sentinelServerUrl, vulnId, apiKey, Convert.ToInt32(isGetdetails), Convert.ToInt32(isGetdetails));

            vulnDetailUrl += DISPLAY_PATCHES;
            vulnDetailUrl+= Constant.getMetricsString();

            HttpWebRequest vulnDetailRequest = WebRequest.CreateHttp(vulnDetailUrl);
            if (sentinelCookies != null)
                vulnDetailRequest.CookieContainer = sentinelCookies;
            vulnDetailRequest.AllowAutoRedirect = false;
            vulnDetailRequest.UserAgent = Constant.UserAgent;
            vulnDetailRequest.Headers[HttpRequestHeader.AcceptLanguage] = Constant.AcceptLanguage;
            vulnDetailRequest.Headers[HttpRequestHeader.CacheControl] = Constant.CacheControl;
            vulnDetailRequest.Method = "GET";
            string vulnDetailResult;
            HttpWebResponse vulnDetailResponse = (HttpWebResponse)vulnDetailRequest.GetResponse();

            using (StreamReader reader = new StreamReader(vulnDetailResponse.GetResponseStream()))
            {
                vulnDetailResult = reader.ReadToEnd();
            }

            vulnDetailResponse.Close();
            return JsonConvert.DeserializeObject<VulnerabilityInfo.Vulnerability>(vulnDetailResult);

        }

        /// <summary>
        ///     Gets the vuln detail by sentinel page.
        /// </summary>
        /// <param name="sentinelServerUrl">The sentinel server name.</param>
        /// <param name="vulnId">The vuln id.</param>
        /// <param name="sentinelBrowserCookie">The document cookie.</param>
        /// <param name="isGetDetails"></param>
        /// <returns></returns>
        public static VulnerabilityInfo.Vulnerability GetSentinelVulnDetail(string sentinelServerUrl, string vulnId, string sentinelBrowserCookie, bool isGetDetails)
        {
            sentinelServerUrl = Constant.CleanUrl(sentinelServerUrl);
            string vulnDetailBySentinelPageUrl = string.Format(Constant.VulnDetailSentinelCookieUrl, sentinelServerUrl, vulnId, Convert.ToInt32(isGetDetails), Convert.ToInt32(isGetDetails));

            vulnDetailBySentinelPageUrl += DISPLAY_PATCHES;
            //vulnDetailBySentinelPageUrl+= Constant.getMetricsString(); 
            HttpWebRequest request = WebRequest.CreateHttp(vulnDetailBySentinelPageUrl);
            request.AllowAutoRedirect = false;
            request.Headers.Add(HttpRequestHeader.Cookie, sentinelBrowserCookie);

            request.UserAgent = Constant.UserAgent;
            request.Headers[HttpRequestHeader.AcceptLanguage] = Constant.AcceptLanguage;
            request.Headers[HttpRequestHeader.CacheControl] = Constant.CacheControl;

            request.Method = "GET";
            string vulnDetailResult;
            HttpWebResponse vulnDetailResponse = (HttpWebResponse)request.GetResponse();

            using (StreamReader reader = new StreamReader(vulnDetailResponse.GetResponseStream()))
            {
                vulnDetailResult = reader.ReadToEnd();
            }

            vulnDetailResponse.Close();
            return JsonConvert.DeserializeObject<VulnerabilityInfo.Vulnerability>(vulnDetailResult);
        }

        #endregion
    }
}
