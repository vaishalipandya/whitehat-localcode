using System;
using System.Collections.Generic;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text.RegularExpressions;
using System.Windows.Forms;
using WhiteHatSec.Entity;
using WhiteHatSec.Localization.Culture.Resource;
using EnvDTE;
using EnvDTE80;
using log4net;
using Microsoft.VisualStudio.TextManager.Interop;
using Newtonsoft.Json;
using IServiceProvider = Microsoft.VisualStudio.OLE.Interop.IServiceProvider;
using WhiteHatSec.VSIX.TreeGridView;
using WhiteHatSec.VSIX.Utility;
using static WhiteHatSec.VSIX.Utility.Bade64EncodeDecode;
using WhiteHatSec.Shared;
using System.Net;
using System.ComponentModel;
using Microsoft.VisualStudio.PlatformUI;

namespace WhiteHatSec.VSIX.UserControls
{
    /// <summary>
    ///     Vulnerability Trace control -WhiteHat Finding  tab
    /// </summary>
    public partial class VulnerabilityTrace : BaseControl.BaseControl
    {
        #region "Constructor"

        /// <summary>
        ///     Initializes a new instance of the <see cref="VulnerabilityTrace" /> class.
        /// </summary>
        public VulnerabilityTrace()
        {
            try
            {
                InitializeComponent();
                SetStyle(ControlStyles.SupportsTransparentBackColor, true);
                whsFindingSplitContainer.SplitterDistance =
                    (whsFindingSplitContainer.Orientation == Orientation.Vertical
                        ? whsFindingSplitContainer.Width
                        : whsFindingSplitContainer.Height) / 2;
                hideDirctedRemediationTab();
                SetDefaultColors();
                VSColorTheme.ThemeChanged += VSColorTheme_ThemeChanged;
                WHSSolutionTabControl.DrawMode = TabDrawMode.OwnerDrawFixed;
                Paint += new System.Windows.Forms.PaintEventHandler(this.VulnerabilityTrace_Paint);
                WHSSolutionTabControl.DrawItem += new System.Windows.Forms.DrawItemEventHandler(this.TabPages_DrawItem);
                WebBrowserSnippet.DocumentCompleted += new System.Windows.Forms.WebBrowserDocumentCompletedEventHandler(this.WebBrowser_DocumentCompleted);
                WebBrowserDescription.DocumentCompleted += new System.Windows.Forms.WebBrowserDocumentCompletedEventHandler(this.WebBrowser_DocumentCompleted);
                WebBrowserSolution.DocumentCompleted += new System.Windows.Forms.WebBrowserDocumentCompletedEventHandler(this.WebBrowser_DocumentCompleted);
                directedRemediationWebView.DocumentCompleted += new System.Windows.Forms.WebBrowserDocumentCompletedEventHandler(this.WebBrowser_DocumentCompleted);
                treeGridViewWHSFinding.CellFormatting += new System.Windows.Forms.DataGridViewCellFormattingEventHandler(treeGridViewWHSFinding_CellFormatting);
                WebBrowserSnippet.ScriptErrorsSuppressed = true;
                WebBrowserDescription.ScriptErrorsSuppressed = true;
                WebBrowserSolution.ScriptErrorsSuppressed = true;
                directedRemediationWebView.ScriptErrorsSuppressed = true;
            }
            catch (Exception ex)
            {
                Log.Error("****Error Occured On InitializeComponent***** ", ex);
            }
        }



        #endregion

        #region " variable declaration"

        /// <summary>
        /// WhiteHat  parent window control
        /// /// </summary>
        public WhsMainWindow ParentWhsWindow;

        private static string HTML_TAB = "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;";

        /// <summary>
        /// Sort Order 
        /// </summary>
        public string SortOrder;

        /// <summary>
        ///     The vulnerability file name
        /// </summary>
        private string vulnFileName;

        /// <summary>
        ///     The file Browse Window
        /// </summary>
        private BrowseFile browseFile;

        /// <summary>
        ///     The id
        /// </summary>
        public string Id;

        /// <summary>
        ///     The vuln id
        /// </summary>
        public string VulnId;

        /// <summary>
        ///     The  step collection Information
        /// </summary>
        public VulnerabilityInfo.StepCollection StepCollectionInfo;
        /// <summary>
        /// Logger Instance
        /// </summary>
        private static readonly ILog Log = LogManager.GetLogger
            (MethodBase.GetCurrentMethod().DeclaringType);
        /// <summary>
        /// Ascending order 
        /// </summary>
        public const string SortAscending = "Ascending";
        /// <summary>
        /// Descending order
        /// </summary>
        public const string SortDecending = "Decending";
        #endregion

        #region "Events"
        /// <summary>
        /// User control paint event handler.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void VulnerabilityTrace_Paint(object sender, PaintEventArgs e)
        {
            ControlPaint.DrawBorder(e.Graphics, this.WebBrowserSnippet.ClientRectangle, CurrentThemeBackColor, ButtonBorderStyle.Solid);
        }
        /// <summary>
        /// Tree grid view cell formating event handler
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void treeGridViewWHSFinding_CellFormatting(object sender, DataGridViewCellFormattingEventArgs e)
        {
            DataGridViewCell cell = treeGridViewWHSFinding.Rows[e.RowIndex].Cells[e.ColumnIndex];
            if (e.CellStyle.BackColor!=Color.Blue)
            {
                e.CellStyle.ForeColor = CurrentThemeForColor;
                e.CellStyle.BackColor = CurrentThemeBackColor;
            }
        }
        /// <summary>
        /// Webbrowser Document load compltion event handler
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void WebBrowser_DocumentCompleted(object sender, WebBrowserDocumentCompletedEventArgs e)
        {
            if (WebBrowserSnippet.Document != null)
            {
                WebBrowserSnippet.Document.BackColor = CurrentThemeBackColor;
                WebBrowserSnippet.Document.ForeColor = CurrentThemeForColor;
            }
            else
            {
                WebBrowserSnippet.DocumentText = GetHtmlBackgroundColor();
            }
            if (WebBrowserDescription.Document != null)
            {
                WebBrowserDescription.Document.BackColor = CurrentThemeBackColor;
                WebBrowserDescription.Document.ForeColor = CurrentThemeForColor;
            }
            else
            {
                WebBrowserDescription.DocumentText = GetHtmlBackgroundColor();
            }
            if (WebBrowserSolution.Document != null)
            {
                WebBrowserSolution.Document.BackColor = CurrentThemeBackColor;
                WebBrowserSolution.Document.ForeColor = CurrentThemeForColor;
            }
            else
            {
                WebBrowserSolution.DocumentText = GetHtmlBackgroundColor();
            }
            if (directedRemediationWebView.Document != null)
            {
                directedRemediationWebView.Document.BackColor = CurrentThemeBackColor;
                directedRemediationWebView.Document.ForeColor = CurrentThemeForColor;
            }
            else
            {
                directedRemediationWebView.DocumentText = GetHtmlBackgroundColor();
            }
        }
        /// <summary>
        /// Visual studio theme change event handler
        /// </summary>
        /// <param name="e"></param>
        void VSColorTheme_ThemeChanged(ThemeChangedEventArgs e)
        {
            SetDefaultColors();
        }
        /// <summary>
        /// Hide directed remidiation tab.
        /// </summary>
        private void TabPages_DrawItem(object sender, DrawItemEventArgs e)
        {
            Brush backBrush;
            Brush foreBrush;

            backBrush = new SolidBrush(CurrentThemeBackColor);
            foreBrush = new SolidBrush(CurrentThemeForColor);

            Graphics g = e.Graphics;
            var currentThemeBorderColor = VSColorTheme.GetThemedColor(EnvironmentColors.DropDownBorderColorKey);
            Pen p = new Pen(CurrentThemeBackColor, 10);
            g.DrawRectangle(p, this.WHSSolutionTabControl.Bounds);
            e.Graphics.FillRectangle(backBrush, e.Bounds);
            g.DrawRectangle(new Pen(currentThemeBorderColor, 2), this.WHSSolutionTabControl.Bounds);

            StringFormat sf = new StringFormat();
            sf.Alignment = StringAlignment.Center;

            if (WHSSolutionTabControl.TabPages[e.Index].Text.Contains("Directed"))
            {
                sf.Alignment = StringAlignment.Near;
                Rectangle r = e.Bounds;
                r = new Rectangle(r.X, r.Y, r.Width + 30, r.Height + 10);
                e.Graphics.DrawString(WHSSolutionTabControl.TabPages[e.Index].Text, e.Font, foreBrush, r, sf);
            }
            else
            {
                Rectangle r = e.Bounds;
                r = new Rectangle(r.X, r.Y, r.Width, r.Height + 10);
                e.Graphics.DrawString(WHSSolutionTabControl.TabPages[e.Index].Text, e.Font, foreBrush, r, sf);
            }

            Rectangle lasttabrect = WHSSolutionTabControl.GetTabRect(WHSSolutionTabControl.TabPages.Count - 1);
            Rectangle background = new Rectangle();
            background.Location = new Point(lasttabrect.Right, 0);

            RectangleF emptyspacerect = new RectangleF(
            lasttabrect.X + lasttabrect.Width + WHSSolutionTabControl.Left,
            WHSSolutionTabControl.Top + lasttabrect.Y,
            WHSSolutionTabControl.Width - (lasttabrect.X + lasttabrect.Width),
            lasttabrect.Height);
            e.Graphics.FillRectangle(backBrush, emptyspacerect);
        }
        /// <summary>
        ///     Sort Vulnerability trace by Vuln Id
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">The <see cref="DataGridViewCellMouseEventArgs" /> instance containing the event data.</param>
        /// 
        private void TreeGridViewWHSFinding_ColumnHeaderMouseClick(object sender, DataGridViewCellMouseEventArgs e)
        {
            // Collapse all node before sorting 
            GenerateVulnTrace(0, SortAscending);
            if (SortOrder != SortDecending)
            {
                SortOrder = SortDecending;
                GenerateVulnTrace(Convert.ToInt32(BaseInstance.ActiveVulnId), SortOrder);
            }
            else
            {
                SortOrder = SortAscending;
                GenerateVulnTrace(Convert.ToInt32(BaseInstance.ActiveVulnId), SortOrder);
            }
        }

        /// <summary>
        ///     Handles the Click event of the btnBrowseFolder control to browse directory.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">The <see cref="EventArgs" /> instance containing the event data.</param>
        private void BtnBrowseFolder_Click(object sender, EventArgs e)
        {
            try
            {
                if (folderBrowserDialog.ShowDialog() != DialogResult.OK)
                {
                    return;
                }
                TxtFolderPath.Text = folderBrowserDialog.SelectedPath;

            }
            catch (Exception ex)
            {
                Log.Error("****Error Occured On Browse Folder button click in WHS finding tab***** ", ex);
                MessageBox.Show("Error occured while browsing for folder", MessageLog.ErrorMessage, MessageBoxButtons.OK,
                    MessageBoxIcon.Error);
            }
        }

        /// <summary>
        ///     Handles the Checked Changed event of the GetDetailsToolStripMenuItem control to display solution and descriotion.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">The <see cref="EventArgs" /> instance containing the event data.</param>
        public void GetDetailsToolStripMenuItem_CheckedChanged(object sender, EventArgs e)
        {
            try
            {
                if (ParentWhsWindow == null ||
                    string.IsNullOrEmpty(BaseInstance.ActiveVulnId))
                {
                    WebBrowserDescription.DocumentText = string.Empty;
                    WebBrowserSolution.DocumentText = string.Empty;
                }
                else
                {
                    ShowDescriptionSoultion(BaseInstance.VulnerabilityList.SingleOrDefault(x => x.Id == Convert.ToInt32(BaseInstance.ActiveVulnId)));
                }
            }
            catch (Exception ex)
            {
                Log.Error("****Error Occured On checking or unchecking get detail context menu***** ", ex);
                MessageBox.Show("Error occured while Checking Get detail.", MessageLog.ErrorMessage,
                    MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        /// <summary>
        ///     Handles the Node Expanding event of the treeGridViewWHSFinding control.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">The <see cref="ExpandingEventArgs" /> instance containing the event data.</param>
        private void TreeGridViewWHSFinding_NodeExpanding(object sender, ExpandingEventArgs e)
        {
            try
            {
                string id = Convert.ToString(treeGridViewWHSFinding.Rows[e.Node.RowIndex].Cells[0].Value);
                if (!string.IsNullOrEmpty(id))
                    BaseInstance.ActiveVulnId = Convert.ToString(treeGridViewWHSFinding.Rows[e.Node.RowIndex].Cells[0].Value);
                WHSSolutionTabControl.SelectedIndex = 0;
                if (e.Node.Image != null)
                {
                    e.Node.Image = Resources.Resources.DownArrow;
                }
            }
            catch (Exception ex)
            {
                Log.Error("****Error Occured On vuln. trace tree table Node Expanding ***** ", ex);
            }
        }

        /// <summary>
        ///     Handles the Node Collapsing event of the treeGridViewWHSFinding control.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">The <see cref="CollapsingEventArgs" /> instance containing the event data.</param>
        private void TreeGridViewWHSFinding_NodeCollapsing(object sender, CollapsingEventArgs e)
        {
            try
            {
                if (e.Node.Image != null)
                {
                    e.Node.Image = Resources.Resources.Arrow;
                }
            }
            catch (Exception ex)
            {
                Log.Error("****Error Occured On vuln. trace tree table Node Collapsing ***** ", ex);
            }
        }

        //************************************************************************************************************************************************************************************************************************

        /// <summary>
        ///     Handles the Cell Double Click event of the treeGridViewWHSFinding control to open file.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">The <see cref="DataGridViewCellEventArgs" /> instance containing the event data.</param>
        private void TreeGridViewWHSFinding_CellDoubleClick(object sender, DataGridViewCellEventArgs e)
        {
            try
            {
                if (e.RowIndex <= -1)
                {
                    return;
                }

                string vulnerabilityFileUrl = Convert.ToString(treeGridViewWHSFinding.Rows[e.RowIndex].Cells[3].Value);

                //Check for vuln file weather field empty or not, if blank then no need to open it
                if (string.IsNullOrEmpty(vulnerabilityFileUrl))
                {
                    return;
                }

                vulnFileName = Path.GetFileName(vulnerabilityFileUrl);
                bool isValid = DoFileOperation(vulnFileName, TxtFolderPath.Text.Trim(), ParentWhsWindow.VisualStudioCurrentInstance);
                if (isValid == false) Log.Error("****Error Occured On vuln. trace tree table double click ***** ");

            }
            catch (Exception ex)
            {
                Log.Error("****Error Occured On vuln. trace tree table double click ***** ", ex);
            }
        }

        /// <summary>
        ///     Handles the Click event of the btnBrowseFile control to browse file.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">The <see cref="EventArgs" /> instance containing the event data.</param>
        private void BtnBrowseFile_Click(object sender, EventArgs e)
        {
            try
            {
                OpenFileDialog fileDialogBox = new OpenFileDialog
                {
                    Title = MessageLog.BrowseFile,
                    InitialDirectory = @"c:\",
                    Filter = "All files (*.*)|*.*|All files (*.*)|*.*",
                    FilterIndex = 2,
                    RestoreDirectory = true
                };

                if (fileDialogBox.ShowDialog() != DialogResult.OK)
                {
                    return;
                }
                string diffFile = CheckSameFileName(Path.GetFileName(fileDialogBox.FileName), vulnFileName);
                if (!string.IsNullOrEmpty(diffFile))
                {
                    //display message that browsed file and vuln file is different
                    browseFile.LblBrowseFile.Text = diffFile;
                    return;
                }

                //Browse file name and vulnerability file name same, then open it                  
                Log.Info("****Going to open file after browsing from external file****");
                browseFile.Dispose();
                OpenFile(
                    ParentWhsWindow.VisualStudioCurrentInstance.ActiveWindow.ProjectItem,
                    false,
                    fileDialogBox.FileName,
                    ParentWhsWindow.VisualStudioCurrentInstance);
                Log.Info(
                    "****Successfully open file after browsing from browse file and Highlighted the match code****");
                fileDialogBox.Dispose();

            }
            catch (Exception ex)
            {
                Log.Error("****Error occured on browsing file***** ", ex);
                MessageBox.Show("Error occured on browsing file", MessageLog.ErrorMessage, MessageBoxButtons.OK,
                    MessageBoxIcon.Error);
            }
        }

        /// <summary>
        ///     Handles the Load event of the WHSFindingWindow control.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">The <see cref="EventArgs" /> instance containing the event data.</param>
        public void WHSFindingWindow_Load(object sender, EventArgs e)
        {
            try
            {
                if (ParentWhsWindow != null)
                {
                    ParentWhsWindow.GetDetailsToolStripMenuItem.CheckedChanged += GetDetailsToolStripMenuItem_CheckedChanged;
                }
                imageStrip.ImageSize = new Size(16, 16);
                imageStrip.TransparentColor = Color.Magenta;
                imageStrip.ImageSize = new Size(16, 16);
                imageStrip.Images.AddStrip(Resources.Resources.Arrow);

                treeGridViewWHSFinding.ImageList = imageStrip;
                treeGridViewWHSFinding.ShowPlusMinus = false;

                QaFilterInfo.VulnerabilityTraceInfo = this;
            }
            catch (Exception ex)
            {
                Log.Error("****Error occured WHS Finding on Load*****", ex);
            }
        }

        /// <summary>
        ///     Handles the Click event of the ImportSentinelResultsToolStripMenuItem control to import manually vuln data.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">The <see cref="EventArgs" /> instance containing the event data.</param>
        public void ImportSentinelResultsToolStripMenuItem_Click(object sender, EventArgs e)
        {
            try
            {
                OpenFileDialog folderDialog = new OpenFileDialog
                {
                    Title = MessageLog.BrowseFile,
                    InitialDirectory = @"c:\",
                    Filter = Constant.ImportFileTypeFilter,
                    FilterIndex = 2,
                    RestoreDirectory = true
                };
                if (folderDialog.ShowDialog() != DialogResult.OK)
                {
                    return;
                }

                Log.Info("****Going to Import Sentinel****");

                string filecontent = ReadFile(folderDialog.FileName.Trim());
                if (string.IsNullOrEmpty(filecontent))
                {
                    //File is empty
                    MessageBox.Show(MessageLog.FileIsEmpty, MessageLog.Message, MessageBoxButtons.OK,
                        MessageBoxIcon.Information);
                    return;
                }
                try
                {
                    ParentWhsWindow.WHSTabControl.SelectedIndex = 1;
                    //Convert Json data to List
                    VulnerabilityInfo.Vulnerability vulnerability = ConvertJsonToList(filecontent);
                    BaseInstance.VulnerabilityList.Clear();
                    BaseInstance.VulnerabilityList.Add(vulnerability);
                    GenerateVulnTrace(vulnerability.Id, SortAscending);
                    Log.Info("****Successfully sentinel vuln imported****");
                }
                catch (JsonSerializationException)
                {
                    //Import file format is not matching with whs json format
                    MessageBox.Show(MessageLog.FailedToParseJson, MessageLog.ErrorMessage, MessageBoxButtons.OK,
                        MessageBoxIcon.Error);
                }
                catch (Exception)
                {
                    MessageBox.Show(MessageLog.ImportProperJsonFile, MessageLog.ErrorMessage,
                        MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
            }
            catch (Exception ex)
            {
                Log.Error("****Error occured on Importing sentinel*****", ex);
                MessageBox.Show("Error occured on importing sentinel", MessageLog.ErrorMessage, MessageBoxButtons.OK,
                    MessageBoxIcon.Error);
            }
        }

        /// <summary>
        ///     Handles the Cell Click event of the treeGridViewWHSFinding control to get file linenumber, method signature etc.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">The <see cref="DataGridViewCellEventArgs" /> instance containing the event data.</param>
        private void TreeGridViewWHSFinding_CellClick(object sender, DataGridViewCellEventArgs e)
        {
            try
            {
                WebBrowserSnippet.DocumentText = string.Empty;
                if (e.RowIndex <= -1)
                {
                    return;
                }
                Id = Convert.ToString(treeGridViewWHSFinding.Rows[e.RowIndex].Cells[0].Value);
                if (treeGridViewWHSFinding.CurrentNode.Level == 1)
                {
                    BaseInstance.ActiveVulnId = Id;
                }

                else if (treeGridViewWHSFinding.CurrentNode.HasChildren == true &&
                    treeGridViewWHSFinding.CurrentNode.Parent.Parent == null)
                {
                    BaseInstance.ActiveVulnId = Convert.ToString(treeGridViewWHSFinding.CurrentRow.Parent.Cells[0].Value);
                }
                else if (treeGridViewWHSFinding.CurrentNode.HasChildren == false)
                {
                    BaseInstance.ActiveVulnId = Convert.ToString(treeGridViewWHSFinding.CurrentNode.Parent.Parent.Cells[0].Value);
                }

                VulnId = Convert.ToString(treeGridViewWHSFinding.Rows[e.RowIndex].Cells[1].Value);

                try
                {
                    int vid = Convert.ToInt32(VulnId);
                    generateDirectedRemediation(vid);
                }
                catch (Exception ex)
                {
                    hideDirctedRemediationTab();
                }


                var traceId = Convert.ToString(treeGridViewWHSFinding.Rows[e.RowIndex].Cells[4].Value);
                WHSSolutionTabControl.SelectedIndex = 0;
                LoadFindingsSubTab(Id, VulnId, traceId);



            }
            catch (Exception ex)
            {
                Log.Error("****Error occured on Vuln. trace tree table cell click*****", ex);
            }
        }

        /// <summary>
        ///     Handles the Click event of the ClearFindings control to clear all data.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">The <see cref="EventArgs" /> instance containing the event data.</param>
        private void ClearFindings_Click(object sender, EventArgs e)
        {
            try
            {
                ClearFindingsData();
            }
            catch (Exception ex)
            {
                Log.Error("****Error occured on clear findings of vulns. in WHS finding tab*****", ex);
                MessageBox.Show("Error occured on clear whitehat findings", MessageLog.ErrorMessage,
                    MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        /// <summary>
        ///     Handles the Selected event of the WHSSolutionTabControl control.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">The <see cref="TabControlEventArgs" /> instance containing the event data.</param>
        private void WHSSolutionTabControl_Selected(object sender, TabControlEventArgs e)
        {
            try
            {
                if (!BaseInstance.IsAuthenticated && !BaseInstance.IsAuthenticatedByApiKey)
                {
                    WHSSolutionTabControl.SelectedIndex = 0;
                }
                else if (e.TabPage.Name.Equals(tabPageQa.Name))
                {
                    Cursor.Current = Cursors.WaitCursor;

                    QaFilterInfo.LoadQuestionAnswer();

                    QaFilterInfo.BindQaData(BaseInstance.ActiveVulnId, SortAscending);

                    Cursor.Current = Cursors.Default;
                }
            }
            catch (Exception ex)
            {
                Cursor.Current = Cursors.Default;
                Log.Error("****Error occured on changing of index of solution tab control*****", ex);
            }
        }
        /// <summary>
        /// generate the directed remidiation tab.
        /// </summary>
        public void generateDirectedRemediation(int vulnId)
        {
            bool isRemediationVuln = false;
            foreach (VulnerabilityInfo.Vulnerability vuln in BaseInstance.VulnerabilityList)
            {
                if (vuln.Id == vulnId &&
                    !string.IsNullOrEmpty(vuln.remediation_available) &&
                    !vuln.remediation_available.Equals("0"))
                {
                    displayDirectedRemediationHTML(vuln);
                    isRemediationVuln = true;
                }
            }
            if (!isRemediationVuln)
            {
                hideDirctedRemediationTab();
            }
        }

        private void displayDirectedRemediationHTML(VulnerabilityInfo.Vulnerability vuln)
        {
            showDirectedRemediationTab();

            string html = "<HTML>";
            if (vuln.patches != null && vuln.patches.Collection.Count > 0)
            {
                foreach (string patch in vuln.patches.Collection)
                {
                    html += "<hr />";
                    html += string.Format("<a href=\"{0}\">Download Dependency</a>&nbsp;&nbsp;<a href=\"{1}\">Download Patch</a><br /><br />", Constant.PatchLibDownloadUrl, patch);

                    string[] patchRaw = Base64Decode(patch).Split(new string[] { "\r\n", "\n" }, StringSplitOptions.None);
                    foreach (string split in patchRaw)
                    {
                        string splitClean = split.Replace("\t", HTML_TAB);
                        if (splitClean.Length > 0 && splitClean[0] == '-')
                        {
                            html += String.Format("<font color=\"red\">{0}</font><br/>", splitClean);
                        }
                        else if (splitClean.Length > 0 && splitClean[0] == '+')
                        {
                            html += String.Format("<font color=\"green\">{0}</font><br/>", splitClean);
                        }
                        else
                        {
                            html += String.Format("{0}<br />", splitClean);
                        }
                    }
                }
            }
            html += "</HTML>";
            directedRemediationWebView.DocumentText = html;
        }
        /// <summary>
        /// Show directed remidiation tab.
        /// </summary>
        private void showDirectedRemediationTab()
        {
            if (!WHSSolutionTabControl.TabPages.Contains(directedRemediationTab))
            {
                int tabCount = WHSSolutionTabControl.TabCount;
                WHSSolutionTabControl.TabPages.Insert(tabCount, directedRemediationTab);
                WHSSolutionTabControl.Refresh();
                WHSSolutionTabControl.Invalidate();
            }
        }
        /// <summary>
        /// Hide directed remidiation tab.
        /// </summary>
        private void hideDirctedRemediationTab()
        {
            if (WHSSolutionTabControl.TabPages.Contains(directedRemediationTab))
            {
                WHSSolutionTabControl.TabPages.Remove(directedRemediationTab);
                WHSSolutionTabControl.Refresh();
            }
        }


        #endregion

        #region "Methods"
        /// <summary>
        /// Converts the Color to html string
        /// </summary>
        /// <returns></returns>
        public string GetHtmlBackgroundColor()
        {
            string colorCode = ColorTranslator.ToHtml(CurrentThemeBackColor).ToString();
            return "<html><body style='background-color:" + colorCode + "'></body></html>";
        }
        /// <summary>
        /// Clear findings Data
        /// </summary>
        public void ClearFindingsData()
        {
            BaseInstance.VulnerabilityList.Clear();
            GenerateVulnTrace(0, SortAscending);
            TxtFolderPath.Text = string.Empty;
            WebBrowserSnippet.DocumentText = string.Empty;
            WHSSolutionTabControl.SelectedIndex = 0;
            WebBrowserDescription.DocumentText = string.Empty;
            WebBrowserSolution.DocumentText = string.Empty;
            BaseInstance.ActiveVulnId = string.Empty;
            QaFilterInfo.CreateQaData(null, SortAscending);
            directedRemediationWebView.DocumentText = string.Empty;

        }
        /// <summary>
        /// Check for selected same file as vuln file
        /// </summary>
        /// <param name="selectedFile"></param>
        /// <param name="vulnFile"></param>
        /// <returns></returns>
        public string CheckSameFileName(string selectedFile, string vulnFile)
        {
            return selectedFile.ToLower() != vulnFile.ToLower() ? MessageLog.SelectedFilenameIsDifferentThenRowPointedFile : string.Empty;
        }

        /// <summary>
        ///     Changes the container orientation.
        /// </summary>
        /// <param name="orientation">The orientation.</param>
        public void ChangeOrientation(Orientation orientation)
        {
            try
            {
                whsFindingSplitContainer.Orientation = orientation;
                whsFindingSplitContainer.SplitterDistance =
                    (orientation == Orientation.Vertical
                        ? whsFindingSplitContainer.Width
                        : whsFindingSplitContainer.Height) / 2;
            }
            catch (Exception ex)
            {
                Log.Error("****Error occured in method of changing orientation of show solution*****", ex);
            }
        }

        /// <summary>
        ///     Binds the vulnerability trace data .
        /// <param name="vulnId">The Vuln Id.</param>
        /// <param name="sortOrder">The sortOrder.</param>
        /// </summary>
        ///************************************************************************************************************************************************************************************************************************

        public void GenerateVulnTrace(int vulnId, string sortOrder)
        {
            try
            {
                Log.Info("****Going to bind vuln. trace tree table****");
                treeGridViewWHSFinding.ShowPlusMinus = false;
                int vulnerabilityTraceCount = BaseInstance.VulnerabilityList.Count;
                BaseInstance.VulnerabilityList = SortVulnerabilityData(BaseInstance.VulnerabilityList, sortOrder);
                treeGridViewWHSFinding.Nodes.Clear();
                BaseInstance.ActiveVulnId = "0";
                if (vulnerabilityTraceCount > 0)
                {
                    BaseInstance.ActiveVulnId = Convert.ToString(vulnId);
                }
                CreateTreeGrid(vulnId);
            }
            catch (Exception ex)
            {
                Log.Error("****Error occured in binding vuln. trace tree table method*****", ex);
            }
        }

        /// <summary>
        /// Set default color based on current theme of visual studio.
        /// </summary>
        void SetDefaultColors()
        {
            treeGridViewWHSFinding.BackgroundColor = CurrentThemeBackColor;
            treeGridViewWHSFinding.ForeColor = CurrentThemeForColor;
            panel1.BackColor = CurrentThemeBackColor;
            panelSourceFolder.BackColor = CurrentThemeBackColor;
            btnBrowseFolder.BackColor = CurrentThemeBackColor;
            btnBrowseFolder.ForeColor = CurrentThemeForColor;
            TxtFolderPath.BackColor = CurrentThemeBackColor;
            TxtFolderPath.ForeColor = CurrentThemeForColor;
            treeGridViewWHSFinding.DefaultCellStyle.BackColor = CurrentThemeBackColor;
            treeGridViewWHSFinding.DefaultCellStyle.ForeColor = CurrentThemeForColor;
            treeGridViewWHSFinding.ColumnHeadersDefaultCellStyle.BackColor = CurrentThemeBackColor;
            treeGridViewWHSFinding.ColumnHeadersDefaultCellStyle.ForeColor = CurrentThemeForColor;
            treeGridViewWHSFinding.RowsDefaultCellStyle.BackColor = CurrentThemeBackColor;
            treeGridViewWHSFinding.AlternatingRowsDefaultCellStyle.BackColor = CurrentThemeBackColor;
            treeGridViewWHSFinding.GridColor = CurrentThemeBackColor;
            treeGridViewWHSFinding.EnableHeadersVisualStyles = false;
            treeGridViewWHSFinding.ColumnHeadersBorderStyle = DataGridViewHeaderBorderStyle.None;
            WHSSolutionTabControl.Invalidate();
            textBox2.BackColor = CurrentThemeBackColor;
            textBox2.ForeColor = CurrentThemeForColor;
            whsFindingSplitContainer.BackColor = CurrentThemeBorderColor;
            WebBrowser_DocumentCompleted(this.WebBrowserDescription, null);
        }

        /// <summary>
        ///     Loads the snippet from step collection.
        /// </summary>
        /// <param name="stepCollectionInfo">The  step collection.</param>
        /// <exception cref="System.NotImplementedException"></exception>
        public void LoadSnippet(VulnerabilityInfo.StepCollection stepCollectionInfo)
        {
            try
            {
                string snippet = Bade64EncodeDecode.Base64Decode(stepCollectionInfo.Formatted_Code);
                if (string.IsNullOrEmpty(snippet))
                {
                    return;
                }

                if (WebBrowserSnippet.Document != null)
                {
                    WebBrowserSnippet.Document.Write(string.Empty);
                }

                WebBrowserSnippet.DocumentText = snippet;

            }
            catch (Exception ex)
            {
                Log.Error("****Error occured on loading snippet according Vuln. Id*****", ex);
            }
        }

        //*********************************************************************************
        /// <summary>
        /// File Operation for Open and Highlight file 
        /// </summary>
        /// <param name="vulnFile"></param>
        /// <param name="specifyFolderPath"></param>
        /// <param name="currentInstance"></param>
        /// <returns></returns>
        public bool DoFileOperation(string vulnFile, string specifyFolderPath, DTE2 currentInstance)
        {
            string h = currentInstance.Edition;
            if (vulnFile.IndexOf("?") > -1)
            {
                vulnFile = vulnFile.Substring(0, vulnFile.IndexOf("?"));
            }

            ProjectItem projectItem = FindFileInSolution(vulnFile, currentInstance);
            //Find file in current solution
            if (projectItem != null)
            {
                OpenFile(projectItem, true, string.Empty, currentInstance);

            }
            else
            {
                //if file is not in current solution it will find in specific folder

                if (!string.IsNullOrEmpty(specifyFolderPath))
                {
                    FindFileInDir(vulnFile, specifyFolderPath, projectItem, currentInstance);
                }
                else
                {
                    //file not in current solution and specific folder then ask user to browse it
                    BrowseExternalFile(vulnFile);
                }
            }
            return true;
        }
        /// <summary>
        ///  Find method in file and highlight it 
        /// </summary>
        /// <param name="projectItem"></param>
        /// <param name="currentInstance"></param>
        public bool FindMethodHighlight(ProjectItem projectItem, DTE2 currentInstance)
        {
            try
            {
                TextSelection textSelection;
                int startLineNumber = StepCollectionInfo.Start_Line_Number;
                int relativeLineNumber = StepCollectionInfo.Relative_Line_Number;
                if (projectItem.Document != null)
                {
                    textSelection = projectItem.Document.Selection as TextSelection;
                }
                else
                {
                    textSelection = currentInstance.ActiveWindow.Selection as TextSelection;
                }

                //lineNumber index considered from 0. 
                int locateLineNumber = startLineNumber + relativeLineNumber;
                string code = Bade64EncodeDecode.Base64Decode(StepCollectionInfo.Code);
                HighligtMatchLine(code, textSelection, relativeLineNumber, locateLineNumber, projectItem);
            }
            catch (Exception ex)
            {
                Log.Error("****Error occured in method of HighLight VulnLine*****", ex);
            }
            return true;

        }
        /// <summary>
        /// Highlight the mathching code
        /// </summary>
        /// <param name="code"></param>
        /// <param name="textSelection"></param>
        /// <param name="relativeLineNumber"></param>
        /// <param name="locateLineNumber"></param>
        /// <param name="projectItem"></param>
        public void HighligtMatchLine(string code, TextSelection textSelection, int relativeLineNumber, int locateLineNumber, ProjectItem projectItem)
        {
            bool isCodeFound = false;
            if (string.IsNullOrEmpty(code)) return;
            string highlightText = Common.GetLine(code, relativeLineNumber);
            if (string.IsNullOrEmpty(highlightText))
            {
                return;
            }

            highlightText = highlightText.Trim();
            highlightText = Regex.Replace(highlightText, @"\s+", string.Empty);
            string[] totalFileLine = File.ReadAllLines(projectItem.FileNames[1]);
            if (totalFileLine.Count() < locateLineNumber)
            {  //If file having lesser line than data line , not able to mathch code
                MessageBox.Show(MessageLog.NotAbleToMatchLineAndMethod, "Message", MessageBoxButtons.OK, MessageBoxIcon.Information);
                return;
            }
            //Match code  line in file 
            isCodeFound = MatchLine(totalFileLine, locateLineNumber, highlightText, textSelection);
            if (isCodeFound)
            {
                return;
            }

            //if match code is not found in file,Match method in file
            isCodeFound = MatchMethod(code, totalFileLine, textSelection);
            if (isCodeFound)
            {
                return;
            }
            //Display message that neithr line of code nor method mathch in file
            MessageBox.Show(MessageLog.NotAbleToMatchLineAndMethod, "Message", MessageBoxButtons.OK, MessageBoxIcon.Information);
        }
        /// <summary>
        /// Mathc method in file
        /// </summary>
        /// <param name="code"></param>
        /// <param name="totalFileLine"></param>
        /// <param name="textSelection"></param>
        public bool MatchMethod(string code, string[] totalFileLine, TextSelection textSelection)
        {
            string methodSignature = Common.GetLine(code, 0);
            if (string.IsNullOrEmpty(methodSignature))
            {
                return false;
            }
            methodSignature = methodSignature.Trim();
            methodSignature = Regex.Replace(methodSignature, @"\s+", string.Empty);
            for (int i = 0; i < totalFileLine.Count(); i++)
            {
                string matchLine = Regex.Replace(totalFileLine[i], @"\s+", string.Empty);
                if (!matchLine.Contains(methodSignature))
                    continue;
                Log.Info(
                    "****Going to highlight code after matching Vuln. method signature****");
                textSelection.GotoLine(i + 1, true);
                CreateMarker(i);
                MessageBox.Show(MessageLog.NotAbleToMatchLineButAbleToFindMatchForMethod,
                    MessageLog.Message, MessageBoxButtons.OK, MessageBoxIcon.Information);
                Log.Info(
                    "****Successfully highlighted code after matching Vuln. method signature****");
                return true;
            }

            return false;
        }
        /// <summary>
        /// Match line of code in file
        /// </summary>
        /// <param name="totalFileLine"></param>
        /// <param name="locateLineNumber"></param>
        /// <param name="highlightText"></param>
        /// <param name="textSelection"></param>
        /// <returns></returns>
        public bool MatchLine(string[] totalFileLine, int locateLineNumber, string highlightText, TextSelection textSelection)
        {
            bool isMatchedString = false;
            string matchLocateLine = Regex.Replace(totalFileLine[locateLineNumber - 1], @"\s+", string.Empty);
            if (matchLocateLine.Contains(highlightText))
            {
                textSelection.GotoLine(locateLineNumber, true);
                isMatchedString = true;
                CreateMarker(locateLineNumber - 1);

            }
            try
            {
                var fromLinenumber = locateLineNumber - Constant.BoundryLines;
                if (fromLinenumber < 0)
                {
                    fromLinenumber = Constant.BoundryLines - locateLineNumber;
                }
                //Check the line to match 30 lines upper and lower as per LineBonudryForMethodMatch
                for (int index = fromLinenumber; index <= (locateLineNumber + Constant.BoundryLines); index++)
                {
                    if (totalFileLine.Count() < index) continue;
                    string matchCodeLine = Regex.Replace(totalFileLine[index], @"\s+", string.Empty);

                    if (isMatchedString || !matchCodeLine.Contains(highlightText)) continue;

                    textSelection.GotoLine(index + 1, true);
                    CreateMarker(index);
                    return true;
                }
                return isMatchedString;
            }

            catch (Exception ex)
            {
                Log.Error("****Error occured in method of HighLight VulnLine*****", ex);
                return false;
            }

        }
        /// <summary>
        ///     Creates the marker for highlight code.
        /// </summary>
        /// <param name="index">The line number for marker.</param>
        public bool CreateMarker(int index)
        {
            try
            {
                IServiceProvider serviceProvider = (IServiceProvider)ParentWhsWindow.VisualStudioCurrentInstance;
                Guid serviceProviderId = typeof(SVsTextManager).GUID;
                Guid interOpId = typeof(IVsTextManager).GUID;
                IntPtr output;
                serviceProvider.QueryService(ref serviceProviderId, ref interOpId, out output);
                IVsTextManager textManager = (IVsTextManager)Marshal.GetObjectForIUnknown(output);
                int highlightId;
                Guid highlightGuid = new Guid("{3A10998B-8414-484A-B55A-B5FD2F19F6CE}");
                // your highlighted text style guid, This value is not static but need to pass that to register it
                textManager.GetRegisteredMarkerTypeID(ref highlightGuid, out highlightId);
                int linecount;
                IVsTextView textView;
                textManager.GetActiveView(0, null, out textView);
                IVsTextLines textLineBuffer;
                textView.GetBuffer(out textLineBuffer);
                textLineBuffer.GetLineCount(out linecount);
                IVsTextLineMarker textLineMarker;
                if (linecount <= -1) return false;
                IVsTextLineMarker[] markerRef = new IVsTextLineMarker[1];
                string tipText = MessageLog.SASTVulnerabilityWarning;
                TextMarkerClient textMarkerClient = new TextMarkerClient(tipText);

                int textCount = textLineBuffer.CreateLineMarker((int)MARKERTYPE.MARKER_SHORTCUT,
                    index, 0, index, index, textMarkerClient, markerRef);
                if (textCount != 0) return false;
                textLineMarker = markerRef[0];
                textLineMarker.SetVisualStyle((uint)MARKERVISUAL.MV_GLYPH |
                                              (uint)MARKERVISUAL.MV_TIP_FOR_GLYPH);

            }
            catch (Exception ex)
            {
                Log.Error("****Error occured in method of Create Marker*****", ex);
            }
            return true;
        }
        /// <summary>
        /// Find File in current solution
        /// </summary>
        /// <param name="vulnerabilityFileName"></param>
        /// <param name="currentInstance"></param>
        /// <returns></returns>

        public ProjectItem FindFileInSolution(string vulnerabilityFileName, DTE2 currentInstance)
        {
            return SolutionInfo.FindSolutionItemByName(currentInstance, vulnerabilityFileName, true);
        }
        /// <summary>
        /// Open file in current Visual studio IDE
        /// </summary>
        /// <param name="projectItem"></param>
        /// <param name="isSolutionFile"></param>
        /// <param name="fileName"></param>
        /// <param name="currentInstance"></param>
        /// 
        //************************************************************************************************************************************************************************************************************************
        public bool OpenFile(ProjectItem projectItem, bool isSolutionFile, string fileName, DTE2 currentInstance)
        {
            if (isSolutionFile)
            {
                Window visualStudioWindow = projectItem.Open(Constants.vsViewKindCode);
                visualStudioWindow.Activate();
                FindMethodHighlight(projectItem, currentInstance);
                Log.Info(
                "****Successfully open file from current workspace/solution and Highlighted the match code****");
                return true;
            }

            ItemOperations itemOp = currentInstance.ItemOperations;
            itemOp.OpenFile(fileName, Constants.vsViewKindCode);
            ProjectItem projectItemFile = currentInstance.ActiveWindow.ProjectItem;
            FindMethodHighlight(projectItemFile, currentInstance);
            Log.Info(
                "****Successfully open file from external location and Highlighted the match code****");
            return true;



        }
        /// <summary>
        /// Find file in specific folder path
        /// </summary>
        /// <param name="vulnFile"></param>
        /// <param name="specifyFolderPath"></param>
        /// <param name="projectItem"></param>
        /// <param name="currentInstance"></param>
        public bool FindFileInDir(string vulnFile, string specifyFolderPath, ProjectItem projectItem, DTE2 currentInstance)
        {
            Cursor.Current = Cursors.WaitCursor;
            List<string> fileSearchFromDirectory = new List<string>(Directory.GetFiles(specifyFolderPath, vulnFile, SearchOption.AllDirectories));
            foreach (string fileName in fileSearchFromDirectory)
            {
                if (Path.GetFileName(fileName).ToLower() != vulnFile.ToLower())
                    continue;
                specifyFolderPath = fileName;
                break;
            }
            if (Path.GetFileName(specifyFolderPath).ToLower() == vulnFile.ToLower())
            {
                Log.Info("****Going to open file from given browse folder path****");
                OpenFile(currentInstance.ActiveWindow.ProjectItem, false, specifyFolderPath, currentInstance);
                Log.Info("****Successfully open file from given browse folder path and Highlighted the match code****");
                Cursor.Current = Cursors.Default;

            }
            else
            {
                Cursor.Current = Cursors.Default;
                BrowseExternalFile(vulnFile);
            }
            Cursor.Current = Cursors.Default;
            return true;
        }
        /// <summary>
        /// Ask user to browse extrnal file 
        /// </summary>
        /// <param name="vulnerabilityFileName"></param>
        public void BrowseExternalFile(string vulnerabilityFileName)
        {
            browseFile = new BrowseFile
            {
                LblBrowseFile = { Text = String.Format("File {0} does not exist.\nYou must import it in your current workspace before you can apply the patch.", vulnerabilityFileName) }
            };
            browseFile.BtnBrowseFile.Click += BtnBrowseFile_Click;
            browseFile.ShowDialog();
        }
        /// <summary>
        /// Display description and solution 
        /// </summary>
        /// <param name="vulnerability"></param>
        public void ShowDescriptionSoultion(VulnerabilityInfo.Vulnerability vulnerability)
        {
            if (vulnerability == null)
            {
                return;

            }
            BaseInstance.ActiveVulnId = vulnerability.Id.ToString();


            string description = vulnerability.Description;
            string solution = vulnerability.Solution;
            //For Description 
            if (!string.IsNullOrEmpty(description))
            {
                description = description.Replace("<!--[if !supportLists]-->", "<!-- [if !supportLists] -->");
                description = description.Replace("<!--[endif]-->", "<!-- [endif] -->");
            }
            //For solution
            if (!string.IsNullOrEmpty(solution))
            {
                solution = solution.Replace("<!--[if !supportLists]-->", "<!-- [if !supportLists] -->");
                solution = solution.Replace("<!--[endif]-->", "<!-- [endif] -->");
            }

            WebBrowserDescription.DocumentText = !string.IsNullOrEmpty(description) ? description : string.Empty;
            WebBrowserSolution.DocumentText = !string.IsNullOrEmpty(solution) ? solution : string.Empty;

        }

        /// <summary>
        /// Create tree grid structure from data
        /// </summary>
        /// <param name="vulnId"></param>
        public void CreateTreeGrid(int vulnId)
        {
            //Lettle bit complex method as we are creating custom tree grid and assign data to it

            for (int i = 0; i < BaseInstance.VulnerabilityList.Count; i++)
            {
                TreeGridNode node = GenerateNode(vulnId, i);
                node.ImageIndex = 0;
                bool isFirstItem = true;
                //Genearate trace from vuln collection as expanded node
                foreach (VulnerabilityInfo.Collection traceCollection in BaseInstance.VulnerabilityList[i].Traces.Collection)
                {
                    Color blueColor = Color.FromArgb(185, 209, 234);
                    if (!isFirstItem)
                    {
                        node = node.Parent.Parent.Nodes.Add(null, traceCollection.Id, null, null, null, null, null, null);
                        node.DefaultCellStyle.BackColor = blueColor;
                    }
                    else
                    {
                        //Highlight parent with different color
                        node = node.Nodes.Add(null, traceCollection.Id, null, null, null, null, null, null);
                        node.DefaultCellStyle.BackColor = blueColor;
                        isFirstItem = false;
                    }
                    node.ImageIndex = 0;
                    bool isFirstTrace = true;

                    Color gradientInactive = Color.FromArgb(11, 160, 213);
                    //Genearate step collection frrom vuln collection as expanded node of trace
                    foreach (VulnerabilityInfo.StepCollection stepsCollection in traceCollection.Steps.Collection)
                    {
                        if (isFirstTrace)
                        {
                            node = node.Nodes.Add(stepsCollection.Id, BaseInstance.VulnerabilityList[i].Id, stepsCollection.Kind,
                                stepsCollection.Filename, traceCollection.Id, null, null, null);
                            isFirstTrace = false;
                        }
                        else
                        {
                            node = node.Parent.Nodes.Add(stepsCollection.Id, BaseInstance.VulnerabilityList[i].Id, stepsCollection.Kind,
                                stepsCollection.Filename, traceCollection.Id, null, null, null);
                        }

                        node.Cells[0].Style.SelectionForeColor = gradientInactive;
                        node.Cells[1].Style.SelectionForeColor = gradientInactive;
                        node.Cells[4].Style.SelectionForeColor = gradientInactive;
                    }
                }
                applyVulnId(node, vulnId);
                //node.vulnID = vulnId;

                Log.Info("****Successfully binded vuln. trace tree table****");
            }
        }
        public void applyVulnId(TreeGridNode node, int VulnId)
        {
            if (node == null)
            {
                return;
            }

            node.vulnID = VulnId;
            foreach (TreeGridNode n in node.Nodes)
            {
                applyVulnId(n, VulnId);
            }
        }
        /// <summary>
        /// Generate Node
        /// </summary>
        /// <returns></returns>
        public TreeGridNode GenerateNode(int vulnId, int i)
        {
            Color gray = Color.FromArgb(11, 160, 213);
            TreeGridNode node = treeGridViewWHSFinding.Nodes.Add(
                 BaseInstance.VulnerabilityList[i].Id, null, null, null,
                  BaseInstance.VulnerabilityList[i].Class_Readable, BaseInstance.VulnerabilityList[i].Risk, BaseInstance.VulnerabilityList[i].Status, BaseInstance.VulnerabilityList[i].Application_Id);
            if (i == 0)
                node.Selected = false;
            if (BaseInstance.VulnerabilityList[i].Id != vulnId)
            {
                node.DefaultCellStyle.BackColor = gray;
                node.DefaultCellStyle.ForeColor = Color.White;
            }
            else
            {
                node.DefaultCellStyle.ForeColor = Color.White;
                node.DefaultCellStyle.BackColor = Color.Blue;
            }
            return node;
        }

        /// <summary>
        /// Get step collection information to get data for file vuln match
        /// </summary>
        /// <param name="vulnerability"></param>
        /// <param name="traceId"></param>
        /// <param name="id"></param>
        /// <returns></returns>
        public VulnerabilityInfo.StepCollection GetStepCollectionInfo(VulnerabilityInfo.Vulnerability vulnerability, string traceId, string id)
        {

            return vulnerability.Traces.Collection
                           .Where(x => x.Id.Trim() == traceId.Trim()).
                           SelectMany(x => x.Steps.Collection).
                           Select(m => new VulnerabilityInfo.StepCollection
                           {
                               Id = m.Id,
                               Code = m.Code,
                               Formatted_Code = m.Formatted_Code,
                               Relative_Line_Number = m.Relative_Line_Number,
                               Start_Line_Number = m.Start_Line_Number,
                               Method_Signature = m.Method_Signature
                           }).SingleOrDefault(x => x.Id == Convert.ToInt32(id));

        }
        /// <summary>
        /// Sort Vuln Data
        /// </summary>
        /// <param name="vulnList"></param>
        /// <param name="sortOrder"></param>
        /// <returns></returns>
        public List<VulnerabilityInfo.Vulnerability> SortVulnerabilityData(List<VulnerabilityInfo.Vulnerability> vulnList, string sortOrder)
        {
            return sortOrder == SortAscending ? vulnList.OrderBy(x => x.Id).ToList() : vulnList.OrderByDescending(x => x.Id).ToList();
        }
        /// <summary>
        /// Read Json File
        /// </summary>
        /// <param name="fileName"></param>
        /// <returns></returns>
        public string ReadFile(string fileName)
        {
            return File.ReadAllText(fileName);
        }
        /// <summary>
        /// Convert Json data to generic class object
        /// </summary>
        /// <param name="fileContent"></param>
        /// <returns></returns>
        public VulnerabilityInfo.Vulnerability ConvertJsonToList(string fileContent)
        {
            return JsonConvert.DeserializeObject<VulnerabilityInfo.Vulnerability>(fileContent);
        }
        /// <summary>
        /// Load Findings Sub Tab
        /// </summary>
        /// <param name="id"></param>
        /// <param name="vulnId"></param>
        /// <param name="traceId"></param>
        public void LoadFindingsSubTab(string id, string vulnId, string traceId)
        {
            VulnerabilityInfo.Vulnerability vulnerability;


            //If id  not null and vuln Id empty then display description and solution tab
            if (!string.IsNullOrEmpty(id) && string.IsNullOrEmpty(vulnId))
            {
                vulnerability = BaseInstance.VulnerabilityList.SingleOrDefault(x => x.Id == Convert.ToInt32(id));
                ShowDescriptionSoultion(vulnerability);
            }
            //if id, vuln id , traceId not blank then display snippet tab
            if (!string.IsNullOrEmpty(id) && !string.IsNullOrEmpty(vulnId) && !string.IsNullOrEmpty(traceId))
            {
                vulnerability =
                    BaseInstance.VulnerabilityList.SingleOrDefault(x => x.Id == Convert.ToInt32(vulnId));

                if (vulnerability == null)
                {
                    return;
                }
                StepCollectionInfo = GetStepCollectionInfo(vulnerability, traceId, id);
                if (StepCollectionInfo != null)
                {
                    LoadSnippet(StepCollectionInfo);
                }
                else
                {
                    WebBrowserSnippet.DocumentText = string.Empty;
                }
            }
        }


        #endregion
        /// <summary>
        /// Webbrowser navigation event
        /// <param name="sender"></param>
        /// <param name="e"></param>
        /// </summary>
        private void directedRemediation_Navigating(object sender, WebBrowserNavigatingEventArgs e)
        {
            if (e.Url != null && e.Url.Equals(Constant.PatchLibDownloadUrl))
            {
                
                System.Diagnostics.Process browserNaviagtionProcess = new System.Diagnostics.Process();
                try
                {
                    // true is the default, but it is important not to set it to false
                    browserNaviagtionProcess.StartInfo.UseShellExecute = true;
                    browserNaviagtionProcess.StartInfo.FileName = Convert.ToString(e.Url);
                    browserNaviagtionProcess.Start();
                }
                catch (Exception ex)
                {
                    Console.WriteLine(ex.Message);
                }
                directedRemediationWebView.Refresh();
                e.Cancel = true;
            }
           else if (e.Url != null && !e.Url.AbsolutePath.Equals("blank") && !e.Url.AbsolutePath.Equals(Constant.PatchLibDownloadUrl))
            {
                string patch = Base64Decode(e.Url.AbsolutePath);

                SaveFileDialog saveFileDialog = new SaveFileDialog();
                saveFileDialog.FileName = "DirectedRemediation.patch";
                if (saveFileDialog.ShowDialog() == DialogResult.OK)
                {
                    string filepath = saveFileDialog.FileName;
                    using (System.IO.StreamWriter file = new System.IO.StreamWriter(filepath))
                    {
                        file.Write(patch);
                    }
                }
                e.Cancel = true;
            }
        }

    }
}